//C++,10ms,472k
/*
小易总是感觉饥饿，所以作为章鱼的小易经常出去寻找贝壳吃。最开始小易在一个初始位置x_0。对于小易所处的当前位置x，他只能通过神秘的力量移动到 4 * x + 3或者8 * x + 7。因为使用神秘力量要耗费太多体力，所以它只能使用神秘力量最多100,000次。贝壳总生长在能被1,000,000,007整除的位置(比如：位置0，位置1,000,000,007，位置2,000,000,014等)。小易需要你帮忙计算最少需要使用多少次神秘力量就能吃到贝壳。

思路：一次可以从x变到4x+3或8x+7，设f(x)=4x+3=4(x+1)-1，g(x)=8x+7=8(x+1)-1
f(g(x))=32x+31=g(f(x))
那么吃到贝壳的fg操作中，可以把g,f各自集中起来，如ffffgggfgfgfgggfgffg(x)=ffffffffffgggggggggg(x)
又f(f(x))=16x+15=16(x+1)-1,g(g(x))=64x+63=64(x+1)-1
f(f(f(x)))=64x+63=64(x+1)-1
那么f(f(f(x)))=g(g(x))
神秘力量要尽可能少地使用，那么3次f(x)可以替换为2次g(x)，ffffffffffgggggggggg(x)=fgggggggggggggggg(x)
这时就很明确了：如果能吃到贝壳，一定是在2次以内的f(x)操作后剩余的由g(x)完成
可以分3路：一路为0次4x+3，全部由8x+7完成。二路1次4x+3，剩下的都为8x+7。三路2次4x+3，然后8x+7。每操作一次计数器+1。
如果计数器超过10w仍没到贝壳位，则返回吃不到。
*/

#include<cstdio>
int x87(int x, int x43){
    //初始位置x，在4x+3操作需要x43次的情况下（x43=0,1,2），需要使用神秘力量的总次数
    if(x==1000000006)return 100005;    //永远都差1步吃到草的
    int count=0;
    while(x43>0 && x%1000000007!=0){
        x++;
        x=(x*2)%1000000007;
        x=(x*2)%1000000007;
        x=(x+1000000006)%1000000007;
        count++;
        x43--;
    }
    while(x%1000000007!=0){
        x++;
        x=(x*2)%1000000007;
        x=(x*2)%1000000007;
        x=(x*2)%1000000007;
        x=(x+1000000006)%1000000007;
        count++;
        if(count>100000)return 100005;    //次数用完，吃不到
    }
    return count;
}
int main(){
    int x,f1=0,f2=0,f3=0,res=0;
    scanf("%d",&x);
    f1=x87(x,0);
    f2=x87(x,1);
    f3=x87(x,2);
    if(f1<f2)res=f1;
    else res=f2;
    if(f3<res)res=f3;
    if(res>100004)printf("-1\n");
    else printf("%d\n",res);
    return 0;
}